//
// DON'T EDIT. THIS FILE HAS BEEN GENERATED BY wayland-scanner++
//

#pragma once

#include <array>
#include <functional>
#include <memory>
#include <string>
#include <vector>

#include <wayland-client.hpp>
#include <wayland-client-protocol-extra.hpp>

struct zwlr_foreign_toplevel_manager_v1;
struct zwlr_foreign_toplevel_handle_v1;

namespace wayland
{
class zwlr_foreign_toplevel_manager_v1_t;
class zwlr_foreign_toplevel_handle_v1_t;
enum class zwlr_foreign_toplevel_handle_v1_state : uint32_t;
enum class zwlr_foreign_toplevel_handle_v1_error : uint32_t;

namespace detail
{
  extern const wl_interface zwlr_foreign_toplevel_manager_v1_interface;
  extern const wl_interface zwlr_foreign_toplevel_handle_v1_interface;
}

/** \brief list and control opened apps

      The purpose of this protocol is to enable the creation of taskbars
      and docks by providing them with a list of opened applications and
      letting them request certain actions on them, like maximizing, etc.

      After a client binds the zwlr_foreign_toplevel_manager_v1, each opened
      toplevel window will be sent via the toplevel event
    
*/
class zwlr_foreign_toplevel_manager_v1_t : public proxy_t
{
private:
  struct events_t : public detail::events_base_t
  {
    std::function<void(zwlr_foreign_toplevel_handle_v1_t)> toplevel;
    std::function<void()> finished;
  };

  static int dispatcher(uint32_t opcode, const std::vector<detail::any>& args, const std::shared_ptr<detail::events_base_t>& e);

  zwlr_foreign_toplevel_manager_v1_t(proxy_t const &wrapped_proxy, construct_proxy_wrapper_tag /*unused*/);

public:
  zwlr_foreign_toplevel_manager_v1_t();
  explicit zwlr_foreign_toplevel_manager_v1_t(const proxy_t &proxy);
  zwlr_foreign_toplevel_manager_v1_t(zwlr_foreign_toplevel_manager_v1 *p, wrapper_type t = wrapper_type::standard);

  zwlr_foreign_toplevel_manager_v1_t proxy_create_wrapper();

  static const std::string interface_name;

  operator zwlr_foreign_toplevel_manager_v1*() const;

  /** \brief stop sending events

        Indicates the client no longer wishes to receive events for new toplevels.
        However the compositor may emit further toplevel_created events, until
        the finished event is emitted.

        The client must not send any more requests after this one.
      
  */
  void stop();

  /** \brief Minimum protocol version required for the \ref stop function
  */
  static constexpr std::uint32_t stop_since_version = 1;

  /** \brief a toplevel has been created
      \param toplevel 

        This event is emitted whenever a new toplevel window is created. It
        is emitted for all toplevels, regardless of the app that has created
        them.

        All initial details of the toplevel(title, app_id, states, etc.) will
        be sent immediately after this event via the corresponding events in
        zwlr_foreign_toplevel_handle_v1.
      
  */
  std::function<void(zwlr_foreign_toplevel_handle_v1_t)> &on_toplevel();

  /** \brief the compositor has finished with the toplevel manager

        This event indicates that the compositor is done sending events to the
        zwlr_foreign_toplevel_manager_v1. The server will destroy the object
        immediately after sending this request, so it will become invalid and
        the client should free any resources associated with it.
      
  */
  std::function<void()> &on_finished();

};


/** \brief an opened toplevel

      A zwlr_foreign_toplevel_handle_v1 object represents an opened toplevel
      window. Each app may have multiple opened toplevels.

      Each toplevel has a list of outputs it is visible on, conveyed to the
      client with the output_enter and output_leave events.
    
*/
class zwlr_foreign_toplevel_handle_v1_t : public proxy_t
{
private:
  struct events_t : public detail::events_base_t
  {
    std::function<void(std::string)> title;
    std::function<void(std::string)> app_id;
    std::function<void(output_t)> output_enter;
    std::function<void(output_t)> output_leave;
    std::function<void(array_t)> state;
    std::function<void()> done;
    std::function<void()> closed;
    std::function<void(zwlr_foreign_toplevel_handle_v1_t)> parent;
  };

  static int dispatcher(uint32_t opcode, const std::vector<detail::any>& args, const std::shared_ptr<detail::events_base_t>& e);

  zwlr_foreign_toplevel_handle_v1_t(proxy_t const &wrapped_proxy, construct_proxy_wrapper_tag /*unused*/);

public:
  zwlr_foreign_toplevel_handle_v1_t();
  explicit zwlr_foreign_toplevel_handle_v1_t(const proxy_t &proxy);
  zwlr_foreign_toplevel_handle_v1_t(zwlr_foreign_toplevel_handle_v1 *p, wrapper_type t = wrapper_type::standard);

  zwlr_foreign_toplevel_handle_v1_t proxy_create_wrapper();

  static const std::string interface_name;

  operator zwlr_foreign_toplevel_handle_v1*() const;

  /** \brief requests that the toplevel be maximized

        Requests that the toplevel be maximized. If the maximized state actually
        changes, this will be indicated by the state event.
      
  */
  void set_maximized();

  /** \brief Minimum protocol version required for the \ref set_maximized function
  */
  static constexpr std::uint32_t set_maximized_since_version = 1;

  /** \brief requests that the toplevel be unmaximized

        Requests that the toplevel be unmaximized. If the maximized state actually
        changes, this will be indicated by the state event.
      
  */
  void unset_maximized();

  /** \brief Minimum protocol version required for the \ref unset_maximized function
  */
  static constexpr std::uint32_t unset_maximized_since_version = 1;

  /** \brief requests that the toplevel be minimized

        Requests that the toplevel be minimized. If the minimized state actually
        changes, this will be indicated by the state event.
      
  */
  void set_minimized();

  /** \brief Minimum protocol version required for the \ref set_minimized function
  */
  static constexpr std::uint32_t set_minimized_since_version = 1;

  /** \brief requests that the toplevel be unminimized

        Requests that the toplevel be unminimized. If the minimized state actually
        changes, this will be indicated by the state event.
      
  */
  void unset_minimized();

  /** \brief Minimum protocol version required for the \ref unset_minimized function
  */
  static constexpr std::uint32_t unset_minimized_since_version = 1;

  /** \brief activate the toplevel
      \param seat 

        Request that this toplevel be activated on the given seat.
        There is no guarantee the toplevel will be actually activated.
      
  */
  void activate(seat_t const& seat);

  /** \brief Minimum protocol version required for the \ref activate function
  */
  static constexpr std::uint32_t activate_since_version = 1;

  /** \brief request that the toplevel be closed

        Send a request to the toplevel to close itself. The compositor would
        typically use a shell-specific method to carry out this request, for
        example by sending the xdg_toplevel.close event. However, this gives
        no guarantees the toplevel will actually be destroyed. If and when
        this happens, the zwlr_foreign_toplevel_handle_v1.closed event will
        be emitted.
      
  */
  void close();

  /** \brief Minimum protocol version required for the \ref close function
  */
  static constexpr std::uint32_t close_since_version = 1;

  /** \brief the rectangle which represents the toplevel
      \param surface 
      \param x 
      \param y 
      \param width 
      \param height 

        The rectangle of the surface specified in this request corresponds to
        the place where the app using this protocol represents the given toplevel.
        It can be used by the compositor as a hint for some operations, e.g
        minimizing. The client is however not required to set this, in which
        case the compositor is free to decide some default value.

        If the client specifies more than one rectangle, only the last one is
        considered.

        The dimensions are given in surface-local coordinates.
        Setting width=height=0 removes the already-set rectangle.
      
  */
  void set_rectangle(surface_t const& surface, int32_t x, int32_t y, int32_t width, int32_t height);

  /** \brief Minimum protocol version required for the \ref set_rectangle function
  */
  static constexpr std::uint32_t set_rectangle_since_version = 1;

  /** \brief request that the toplevel be fullscreened
      \param output 

        Requests that the toplevel be fullscreened on the given output. If the
        fullscreen state and/or the outputs the toplevel is visible on actually
        change, this will be indicated by the state and output_enter/leave
        events.

        The output parameter is only a hint to the compositor. Also, if output
        is NULL, the compositor should decide which output the toplevel will be
        fullscreened on, if at all.
      
  */
  void set_fullscreen(output_t const& output);

  /** \brief Minimum protocol version required for the \ref set_fullscreen function
  */
  static constexpr std::uint32_t set_fullscreen_since_version = 2;

  /** \brief Check whether the \ref set_fullscreen function is available with
      the currently bound version of the protocol
  */
  bool can_set_fullscreen() const;

  /** \brief request that the toplevel be unfullscreened

        Requests that the toplevel be unfullscreened. If the fullscreen state
        actually changes, this will be indicated by the state event.
      
  */
  void unset_fullscreen();

  /** \brief Minimum protocol version required for the \ref unset_fullscreen function
  */
  static constexpr std::uint32_t unset_fullscreen_since_version = 2;

  /** \brief Check whether the \ref unset_fullscreen function is available with
      the currently bound version of the protocol
  */
  bool can_unset_fullscreen() const;

  /** \brief title change
      \param title 

        This event is emitted whenever the title of the toplevel changes.
      
  */
  std::function<void(std::string)> &on_title();

  /** \brief app-id change
      \param app_id 

        This event is emitted whenever the app-id of the toplevel changes.
      
  */
  std::function<void(std::string)> &on_app_id();

  /** \brief toplevel entered an output
      \param output 

        This event is emitted whenever the toplevel becomes visible on
        the given output. A toplevel may be visible on multiple outputs.
      
  */
  std::function<void(output_t)> &on_output_enter();

  /** \brief toplevel left an output
      \param output 

        This event is emitted whenever the toplevel stops being visible on
        the given output. It is guaranteed that an entered-output event
        with the same output has been emitted before this event.
      
  */
  std::function<void(output_t)> &on_output_leave();

  /** \brief the toplevel state changed
      \param state 

        This event is emitted immediately after the zlw_foreign_toplevel_handle_v1
        is created and each time the toplevel state changes, either because of a
        compositor action or because of a request in this protocol.
      
  */
  std::function<void(array_t)> &on_state();

  /** \brief all information about the toplevel has been sent

        This event is sent after all changes in the toplevel state have been
        sent.

        This allows changes to the zwlr_foreign_toplevel_handle_v1 properties
        to be seen as atomic, even if they happen via multiple events.
      
  */
  std::function<void()> &on_done();

  /** \brief this toplevel has been destroyed

        This event means the toplevel has been destroyed. It is guaranteed there
        won't be any more events for this zwlr_foreign_toplevel_handle_v1. The
        toplevel itself becomes inert so any requests will be ignored except the
        destroy request.
      
  */
  std::function<void()> &on_closed();

  /** \brief parent change
      \param parent 

        This event is emitted whenever the parent of the toplevel changes.

        No event is emitted when the parent handle is destroyed by the client.
      
  */
  std::function<void(zwlr_foreign_toplevel_handle_v1_t)> &on_parent();

};

/** \brief types of states on the toplevel

        The different states that a toplevel can have. These have the same meaning
        as the states with the same names defined in xdg-toplevel
      
  */
enum class zwlr_foreign_toplevel_handle_v1_state : uint32_t
  {
  /** \brief the toplevel is maximized */
  maximized = 0,
  /** \brief the toplevel is minimized */
  minimized = 1,
  /** \brief the toplevel is active */
  activated = 2,
  /** \brief the toplevel is fullscreen */
  fullscreen = 3
};

/** \brief 

  */
enum class zwlr_foreign_toplevel_handle_v1_error : uint32_t
  {
  /** \brief the provided rectangle is invalid */
  invalid_rectangle = 0
};



}
